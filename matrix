#! /bin/bash
trap "echo 'Signal received, exiting'; cleanUp; exit 0" INT HUP TERM

# filename:
# Author: Gerson Lindor Jr.  (lindorg@oregontate.edu)
# Date Created: January 13, 2020
# Last Modified: January 14, 2020

# Debugger mode
# set -x


#@param: $1 - the name of the operations
#
operations() {
    local flag=0;
    local fileFlag=0
    local argsFlag=0
    # check argument count
    local opArgs=2  # the expected amount of arguments for dims, transpose, and mean operations
    # check if file is readable
    fileIsReadable
    fileFlag=$?
    if [ $1 = "add" -o $1 = "multiply" ]
    then
        opArgs=3  # the expected amount of arguments for add and multiply operations
    fi
    checkArgCount $opArgs $numOfArgs
    argFlag=$?
    if [ $fileFlag = 2 -a $argFlag = 0 ]
    then
        echo -e "Argument count is $numOfArgs but the file named by argument is not readable" 1>&2
        exit 1
    elif [ $argFlag = 1 ]
    then
        echo "Argument count is greater than 1" 1>&2
        exit 1
    fi
    if [ $1 = "dims" ]
    then
        dims
        flag=$?
        if [ "$flag" = 0 ]
        then
            showDims
        fi
    elif [ $1 = "transpose" ]
    then
        transpose
        flag=$?
    elif [ $1 = "mean" ]
    then
        mean
        flag=$?
    elif [ $1 = "add" ]
    then
        add "add"
        flag=$?
    elif [ $1 = "multiply" ]
    then
        multiply "multiply"
        flag=$?
    else
        echo "Error: Bad command" 1>&2
        exit 1
    fi
    removeAllTemp
    return $flag
}


#
fileIsReadable() {
    # Argument count cannot be 0
    # test if file exist and it's readable
    local checkSecondFile=0
    if [ -e "$datafilepath" ]
    then
        test -e $matrixB
        checkSecondFile=$?
        if [ "$checkSecondFile" = 1 -a "$numOfArgs" = 3 ]
        then
            echo -e "The file does not exist" 1>&2
            exit 1
        fi
        if [ -r $datafilepath ]  # test if the file is readable for mean, transpose, and dims
        then
            if [ "$numofArgs" = 2 ]
            then
                return 0
            fi
        elif [ ! -r "$datafilepath" -o ! -r "$matrixB" ]
        then
            return 2
        fi
    else
        echo -e "The file does not exist" 1>&2
        exit 1
    fi
    return 0
}


eitherFileISReadable() {
ls
    #change datafilepath to file in position $1
    #call fileIsReadable
    #change datafilepath to file in postion $1
    #call fileIsReadable
    # give error message  either file is not readable

}


#@params: $1 - expected argument count
#         $2 - actual script argument count
checkArgCount() {
    if [ $1 -lt $2 ]
    then
        return 1
    elif [ $numOfArgs = 0 ]
    then
        echo "Error: Operation has not arguments" 1>&2
        exit 1
    fi
    return 0
}


#
dims() {
    # get rows
    rows=$( cat $datafilepath | wc -l )
    # get columns
    local line=$( head -1 $datafilepath ) # grap the first line
    # count the number of elements in a line to find the number of columns
    for i in $line
    do
        cols=$(( cols + 1 ))
    done
    return 0
}


#
showDims() {
    # display matrix dimensions
    echo -e "$rows $cols"
}


#
transpose () {
    local index=1
    
    # get the dimensions of the matrix
    dims
    until [ "$index" -gt "$cols" ]
    do
        # turn column to a row
        local turnToRow="$( cut -f$index $datafilepath | tr '\n' '\t' )"
        # remove the extra tab character at the end
        turnToRow="${turnToRow%?}" 
        # if index equals to 1, then redirect the file
        if [ "$index" = 1 ]
        then
            echo -e "$turnToRow" > "$tempFileA"
        else
            # otherwise append to the same file
            echo -e "$turnToRow" >> "$tempFileA"
        fi
        # increment index
        index=$(( index + 1 ))
    done
    cat "$tempFileA"
}


removeAllTemp() {
    rm -f "$tempFileA"
    rm -f "$tempFileB"
    rm -f "$tempFileC"
    rm -f "$tempFileD"
    rm -f "$tempFileE"
    rm -f "$tempFileF"
}


cleanUp() {
    removeAllTemp
    rm -f datafile*
}


mean()  {
    local sum=0
    # call transpose to make it easier to read each line and calculate the sum
    transpose > "$tempFileD"
    while read line
    do
        # in a loop calculate the sum
        sum=0
        for i in $line
        do
            sum=$((i + sum))
        done
        # calculate the average and append result to a file
        local avg=$(( (sum + (rows/2)*( (sum>0)*2-1)) / rows ))
        echo -e "$avg" >> "$tempFileB"
     done < $tempFileD
     # change the file with mean values from columns to rows
     local hold=$( cat "$tempFileB" | tr '\n' '\t' )
     # trim off the tab character at the end of a line
     hold="${hold%?}"
     echo -e "$hold" > "$tempFileC"
     cat "$tempFileC"
     return 0
}


#
 
addWrong () {
    local newColumn=0
    local tempCol=0
    local tempLine=0
    local sum=0
    local limit=0

    #check for matching dimennsions
    checkDimensions $1
    # merge both matrices to a large file
    paste -s $datafilepath $matrixB > $tempFileA
    cat $tempFileA ###############################################
    # get the number of columns from the large file
    if [ "$cols" -ge "$rows" ]
    then
        newColumn=$(( $cols * 2 ))
    else
        newColumn=$(( $rows * 2 ))
    fi
    limit=$(( $newColumn + 1 ))
    rowCheck=0
    touch $tempFileC
    # in loop:
    for (( i = 1; i < limit; ++i ))
    do
        # extract a column
        cut -f$i $tempFileA > $tempFileE
        #cat $tempFileE ###################################################
        # turn that column to a line
        tempLine=$( cat $tempFileE | tr '\n' '\t' )
        # trim the end, and remove the tab
        tempLine="${tempLine%?}"
        # perform summation
        sum=0
        for j in $tempLine
        do
            sum=$(( j + sum ))
        done
        # check if rowCheck is not equal to the number of rows from original matrix
        if [ "$rowCheck" != "$rows" ]
        then
            echo -e "$sum" >> $tempFileB
        else
            # change tempFileB from columns to rows
            tempLine=$( cat $tempFileB | tr '\n' '\t' )
            tempLine="${tempLine%?}"
            echo -e "$tempLine" > $tempFileB

            test -s $tempFileC
            # if result file is empty: concatenate and override sum to a result file
            if [ "$?" = 1 ]
            then
                cat $tempFileB > $tempFileC
                cat $tempFileC > $tempFileD
            else
                # otherwise: concatenate file the temporary sum file to the result file result file
                ######## paste $tempFileC $tempFileB > $tempFileD
                ####### cat $tempFileC $tempFileB >> $tempFileD
                cat $tempFileD $tempFileB > $tempFileC
            fi
            # override temperory sum file with new sum value, and reset rowCheck
            echo -e "$sum" > $tempFileB
            rowCheck=0
         fi
         rowCheck=$(( $rowCheck + 1 ))
    done
    # endLoop
    # change tempFileB from columns to rows
    tempLine=$( cat $tempFileB | tr '\n' '\t' )
    tempLine="${tempLine%?}"
    echo -e "$tempLine" > $tempFileB
    # concatenate the last row of tempFileB to result file
    cat $tempFileC $tempFileB > $tempFileD
    # output result file for matrix addition
    cat $tempFileD
 ###   cat -A $tempFileD
    return 0
}


add() {
    local limit=0
    # verify dimensions
    checkDimensions $1
    limit=$(( $cols + 1 ))
    local index=1
#    local tempPrev="tempNum$(( index - 1 ))"
#    local tempCurrent="tempNum$index"
    until [ "$index" = "$limit" ]
    do
        local tempPrev="tempNum$(( index - 1 ))"
        local tempCurrent="tempNum$index"
        if [ "$index" -lt 10 ]
        then
            tempCurrent="tempNum0$index"
        fi
#        echo "index = $index"
        # take the columns of the two matrices and combine them to a new file
        mergeColumns $matrixB $datafilepath $index > $tempFileA
        # sum each row of the combined file
        sumOfRows $tempFileA > $tempFileB
        rm -f $tempFileD  # delete file for the next row
        # append sum file to results file
 #       test -s $tempPrev
 #       if [ "$?" = 1 ]
 #       then
 #           cat $tempFileB > $tempPrev
 #       else
 #           cat $tempPrev > $tempCurrent
 #           paste  $tempCurrent $tempFileB > $tempFileE
 #           echo "result progression:"
 #           cat $tempFileE
 #       fi
        index=$(( $index + 1 ))
        cat $tempFileB > $tempCurrent
    done
    # Display results
     #cat tempNum01 > $tempFileE
     #paste $tempFileE tempNum* > $tempFileF 
     paste tempNum* > $tempFileF 
#     paste $tempFileE tempNum* > $tempFileF 
 #    cat $tempFileE
#     index=2
#     echo "limit = $limit"
#     until [ "$index" = "$limit" ]
#     do
#        paste $tempFileE tempNum$index >> $tempFileF
        #paste $tempFileE tempNum$index 
#        index=$(( $index + 1 ))
#     done
#     cat $tempFileE 
     cat  $tempFileF
     rm -f tempNum*
}

#
# @params: $1 is the first matrix
#          $2 is the second matrix
#          $3 is the value of a index
mergeColumns() {
    local columnA
    local columnB

    # take column of first matrix
    cut -f$3 $1 > $tempFileA
    # take column of second matrix
    cut -f$3 $2 > $tempFileB
    # paste them together to another file
    paste $tempFileA $tempFileB > $tempFileC
    # cat new file to stdout
    cat $tempFileC
}


#
# @params: $1 is a matrix
sumOfRows() {
    local sum=0

    while read line
    do
        # in a loop calculate the sum
        sum=0
        for i in $line
        do
            sum=$((i + sum))
        done
        echo -e "$sum" >> $tempFileD
     done < $1
     cat $tempFileD
}




#
multiply() {
    #check dimensions
    checkDimension $1
    return 0
}


#
#@params: $1 holds the name of operations add or multiply
checkDimensions() {
    #check for matching dimennsions
    # get the dimensions of datafilepath
    dims
    local rowsOfA=$rows
    local colsOfA=$cols
    # swap values between variables
    swapMatrix
    # get the dimensions of datafilepath with the swapped matrix
    # reset dimensions
    rows=0
    cols=0
    dims
    local rowsOfB=$rows
    local colsOfB=$cols
    # check dimennsions for add or multiply operations
    if [ "$1" = "add" ]
    then
        if [ "$rowsOfA" != "$rowsOfB" -o "$colsOfA" != "$colsOfB" ]
        then
            echo -n "The dimensions of the input matrices do not allow them to be" 1>&2
            echo " added together following the rules of matrix addition" 1>&2
            exit 1
        fi
    elif [ "$1" = "multiply" ]
    then
        if [ "$colsOfA" != "$rowsOfB" ]
        then
            echo -n "The dimensions of the input matrices do not allow them to be" 1>&2
            echo " mutltiplied together following the rules of matrix multiplication" 1>&2
            exit 1
        fi
     fi
}


swapMatrix() {
    local temp=$datafilepath
    datafilepath=$matrixB
    matrixB=$temp
}


#### Run Script ####

datafilepath="datafile$$"
opsName="N/A"
rows=0
cols=0
numOfArgs="$#"
tempFileA="tempA$$"
tempFileB="tempB$$"
tempFileC="tempC$$"
tempFileD="tempD$$"
tempFileE="tempE$$"
tempFileF="tempF$$"
found=1
commandArg=$0


# checking that command is "matrix"
if [ "$commandArg" != "./matrix" ]
then
    echo "Error: Bad command" 1>&2
    exit 1
fi

# check that the operation is correct
if [ "$1" != "dims" -a "$1" != "transpose" -a "$1" != "mean" -a "$1" != "add" -a "$1" != "multiplay" ]
then
    echo "Error: bad operations" 1>&2
    exit 1
fi

# check for correct number of argument for add and multiply operations
if [ "$numOfArgs" -le 2 ]
then
    if [ "$1" = "add" -o "$1" = "multiply" ]
    then
        echo -e "operations 'add' and 'multiply' must have 3 arguments" 1>&2
        exit 1
    fi
fi

# generate path of file via stdin or a file
if [ "$numOfArgs" = "1" ]
then
    cat > "$datafilepath"
elif [ "$numOfArgs" -ge "2" ]
then
    datafilepath=$2
    if [ "$numOfArgs" -ge "3" ]
    then
        matrixB=$3
    fi
fi

# run dims, transpose, mean, add, or multiply
operations $1 
rm -f datafile*
    


